def _prepare(c):
    # Entrée : Un tableau d'entiers.
    # Sortie : Le tableau éventuellement corrigé.
    #          Le minimum et le maximum du tableau corrigé.
    # Erreur : ValueError si les codes ne sont pas ceux d'une droite discrète.
    if 0 == len(c):
        raise ValueError("La liste des codes est vide.")
    t = c[:]
    dif_ = array.array('l', [])
    for v in t:
        if not v in dif_:
            dif_.append(v)
        # S'il y a plus de trois codes différents il ne peut pas s'agir d'une droite discrète
        if 3 < len(dif_):
            print(dif_)
            raise ValueError("Les codes ne sont pas ceux d'une droite disctète.")
    # Ordonnancement de la liste du plus petit au plus grand.
    for i in range(1, len(dif_)):
        for j in range(i):
            if dif_[j] > dif_[i]:
                dif_[i], dif_[j] = dif_[j], dif_[i]
    # échec si le code excédentaire n'est pas le minimum
    # ou n'est pas en fin de liste de codes
    # ou est présent plus d'une fois
    if 3 == len(dif_) and (dif_[0] != t[len(t) - 1] or 1 != dif_.count(dif_[0])):
        raise ValueError("Les codes ne sont pas ceux d'une droite disctète.")
    # suppression du code excédentaire (le plus petit nécessairement en fin de liste)
    if 3 == len(dif_):
        if dif_[0] != t[len(t) - 1]:
            raise ValueError("Les codes ne sont pas ceux d'une droite disctète.")
        del t[len(t) - 1]
        del dif_[0]
    min_, max_ = dif_[0], dif_[len(dif_) - 1]
    return t, min_, max_


def _algo(c, mini):
    # Se reporter à [3] pour les détails.
    # Entrée : Un tableau d'entiers.
    # Sortie : Le tableau arrangé,
    #          Le premier segment
    #          L'indicateur d'échange.
    echange, g, l = False, 0, []
    # print("*c", c)
    # opération 1
    # retrancher le minimum à tous les éléments
    h = 0
    for i in range(len(c)):
        c[i] -= mini
        if 0 == c[i]:
            h = 0
        else:
            h += 1
        # s'il y a au moins deux 1 consécutifs le code 1 n'est pas isolé
        if 1 < h and not echange:
            echange = True
    # opération 2
    # échanger les 1 et les 0 si requis
    # calculer la longueur des segments
    l.append(0)
    for i in range(len(c)):
        if echange:
            c[i] = 1 - c[i]
        l[len(l) - 1] += 1
        if 1 == c[i]:
            l.append(0)
    # si l n'est pas terminé par 0 c'est que le dernier segment est incomplet
    incomplet = False
    if 0 != l[len(l) - 1]:
        l[len(l) - 1] += 1
        incomplet = True
    else:
        # suppression du dernier élément nul
        del l[len(l) - 1]
    # recherche de la plus petite longueur de palier interne
    if 2 < len(l):
        # print("on passe ici !", incomplet, l)
        lpi = l[1]
        for i in range(2, len(l) - 1):
            if l[i] < lpi:
                lpi = l[i]
    elif 2 == len(l):
        if l[0] < l[len(l) - 1] or not incomplet:
            # print("on passe ici aussi !", incomplet, l)
            lpi = l[len(l) - 1]
        else:
            # print("on passe par là aussi !", l)
            lpi = l[0]
    else:
        # print("algo : on passe par là !", incomplet, l)
        lpi = l[len(l) - 1]
    # print("lpi", lpi)
    # suppression du premier segment dont on conserve la longueur g (pivot)
    if 1 < len(l):
        g = l[0]
        del l[0]
    # suppression du  dernier segment s'il est incomplet
    # et si sa longueur est inférieure ou égale à celle
    # du plus petit segment interne.
    if 1 < len(l) and incomplet and l[len(l) - 1] <= lpi:
        del l[len(l) - 1]
    # opération 3
    # remplacement des codes par leur longueur
    print("algo", "c", c)
    print("algo>", "l", l, "g", g, "echange", echange, "mini", mini)
    return array.array('l', l), g, echange


def _etape1(c):
    # Se reporter à [3] pour les détails.
    # Entrée : Un tableau d'entiers.
    # Sortie : Les caractéristiques a, b, r de la forme quasi affine.
    t, mini, maxi = _prepare(c)
    # critere de fin avec succes
    if maxi == mini:
        # point (1)
        a, b, r = mini, 1, 0
    else:
        l, g, echange = _algo(t, mini)
        # on recommence l'etape 1
        # recursivement jusqu'à ce que
        # tous les codes soient egaux
        # ou qu'une erreur se soit produite
        a, b, r = _etape1(l)
        # aucune erreur ne s'est produite
        # on effectue l'etape 2 a rebours
        # en depilant les appels recursifs
        # on vient soit du point (1) plus haut
        # soit du point (2) ci-dessous
        #
        # point (2)
        a, b, r = _etape2(a, b, r, mini, g, echange)
    print("etape1>", "a", a, "b", b, "r", r)
    return a, b, r


def _etape2(a, b, r, p, g, echange):
    # Se reporter à [3] pour les détails.
    # Entrée : Les caractéristiques de la forme quasi affine.
    #          Le minimum p.
    #          Le pivot g et l'indicateur d'échange.
    # Sortie : les caractéristiques a, b, r de la forme quasi affine.
    # symetrie orthogonale : x' = y ; y' = x
    print("etape2<", "a", a, "b", b, "r", r, "p", p, "g", g, "echange", echange)
    a, b, r = b, a, b - r - 1
    if 0 < g:
        r = r - a * g + b
        # r = (r - a * g) % b
    # symetrie oblique : x' = x ; y' = x - y
    if echange:
        a, b, r = b - a, b, b - r - 1
    # transvection : x' = x ; y' = y - px
    a, b, r = a + p * b, b, r
    print("etape2>", "a", a, "b", b, "r", r)
    return a, b, r


